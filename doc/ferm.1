.\" Automatically generated by Pod::Man 2.28 (Pod::Simple 3.29)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "FERM 1"
.TH FERM 1 "2016-03-30" "ferm 2.3" "FIREWALL RULES MADE EASY"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
ferm \- a firewall rule parser for linux
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
\&\fBferm\fR \fIoptions\fR \fIinputfile\fR
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fBferm\fR is a frontend for \fBiptables\fR. It reads the rules from a
structured configuration file and calls \fIiptables\fR\|(8) to insert them
into the running kernel.
.PP
\&\fBferm\fR's goal is to make firewall rules easy to write and easy to
read. It tries to reduce the tedious task of writing down rules, thus
enabling the firewall administrator to spend more time on developing
good rules than the proper implementation of the rule.
.PP
To achieve this, \fBferm\fR uses a simple but powerful configuration
language, which allows variables, functions, arrays, blocks. It also
allows you to include other files, allowing you to create libraries of
commonly used structures and functions.
.PP
\&\fBferm\fR, pronounced \*(L"firm\*(R", stands for \*(L"For Easy Rule Making\*(R".
.SH "CAUTION"
.IX Header "CAUTION"
This manual page does \fInot\fR indend to teach you how firewalling works
and how to write good rules.  There is already enough documentation on
this topic.
.SH "INTRODUCTION"
.IX Header "INTRODUCTION"
Let's start with a simple example:
.PP
.Vb 3
\&    chain INPUT {
\&        proto tcp ACCEPT;
\&    }
.Ve
.PP
This will add a rule to the predefined input chain, matching and
accepting all tcp packets.  Ok, let's make it more complicated:
.PP
.Vb 3
\&    chain (INPUT OUTPUT) {
\&        proto (udp tcp) ACCEPT;
\&    }
.Ve
.PP
This will insert 4 rules, namely 2 in chain input, and 2 in chain
output, matching and accepting both udp and tcp packets.  Normally you
would type this:
.PP
.Vb 4
\&   iptables \-A INPUT \-p tcp \-j ACCEPT
\&   iptables \-A OUTPUT \-p tcp \-j ACCEPT
\&   iptables \-A INPUT \-p udp \-j ACCEPT
\&   iptables \-A OUTPUT \-p udp \-j ACCEPT
.Ve
.PP
Note how much less typing we need to do? :\-)
.PP
Basically, this is all there is to it, although you can make it quite
more complex. Something to look at:
.PP
.Vb 5
\&   chain INPUT {
\&       policy ACCEPT;
\&       daddr 10.0.0.0/8 proto tcp dport ! ftp jump mychain sport :1023 TOS 4 settos 8 mark 2;
\&       daddr 10.0.0.0/8 proto tcp dport ftp REJECT;
\&   }
.Ve
.PP
My point here is, that *you* need to make nice rules, keep
them readable to you and others, and not make it into a mess.
.PP
It would aid the reader if the resulting firewall rules were placed
here for reference. Also, you could include the nested version with
better readability.
.PP
Try using comments to show what you are doing:
.PP
.Vb 3
\&    # this line enables transparent http\-proxying for the internal network:
\&    proto tcp if eth0 daddr ! 192.168.0.0/255.255.255.0
\&        dport http REDIRECT to\-ports 3128;
.Ve
.PP
You will be thankful for it later!
.PP
.Vb 6
\&    chain INPUT {
\&        policy ACCEPT;
\&        interface (eth0 ppp0) {
\&            # deny access to notorius hackers, return here if no match
\&            # was found to resume normal firewalling
\&            jump badguys;
\&
\&            protocol tcp jump fw_tcp;
\&            protocol udp jump fw_udp;
\&        }
\&    }
.Ve
.PP
The more you nest, the better it looks. Make sure the order you
specify is correct, you would not want to do this:
.PP
.Vb 4
\&    chain FORWARD {
\&        proto ! udp DROP;
\&        proto tcp dport ftp ACCEPT;
\&    }
.Ve
.PP
because the second rule will never match. Best way is to specify
first everyting that is allowed, and then deny everything else.
Look at the examples for more good snapshots. Most people do
something like this:
.PP
.Vb 7
\&    proto tcp {
\&        dport (
\&            ssh http ftp
\&        ) ACCEPT;
\&        dport 1024:65535 ! syn ACCEPT;
\&        DROP;
\&    }
.Ve
.SH "STRUCTURE OF A FIREWALL FILE"
.IX Header "STRUCTURE OF A FIREWALL FILE"
The structure of a proper firewall file looks like  simplified
C\-code. Only a few syntactic characters are used in ferm\-
configuration files. Besides these special caracters, ferm
uses 'keys' and 'values', think of them as options and
parameters, or as variables and values, whatever.
.PP
With these words, you define the characteristics of your firewall.
Every firewall consists of two things: First, look if network
traffic matches certain conditions, and second, what to do
with that traffic.
.PP
You may specify conditions that are valid for the kernel
interface program you are using, probably \fIiptables\fR\|(8). For
instance, in iptables, when you are trying to match tcp
packets, you would say:
.PP
.Vb 1
\&    iptables \-\-protocol tcp
.Ve
.PP
In ferm, this will become:
.PP
.Vb 1
\&    protocol tcp;
.Ve
.PP
Just typing this in ferm doesn't do anything, you need to tell
ferm (actually, you need to tell \fIiptables\fR\|(8) and the kernel) what
to do with any traffic that matches this condition:
.PP
.Vb 1
\&    iptables \-\-protocol tcp \-j ACCEPT
.Ve
.PP
Or, translated to \fBferm\fR:
.PP
.Vb 1
\&    protocol tcp ACCEPT;
.Ve
.PP
The \fB;\fR character is at the end of every ferm rule. Ferm ignores line
breaks, meaning the above example is identical to the following:
.PP
.Vb 2
\&    protocol tcp
\&      ACCEPT;
.Ve
.PP
Here's a list of the special characters:
.IP "\fB;\fR" 8
.IX Item ";"
This character finalizes a rule.
.Sp
Separated by semicolons, you may write multiple rules in one line,
although this decreases readability:
.Sp
.Vb 1
\&    protocol tcp ACCEPT; protocol udp DROP;
.Ve
.IP "\fB{}\fR" 8
.IX Item "{}"
The nesting symbol defines a 'block' of rules.
.Sp
The curly brackets contain any number of nested rules. All matches
before the block are carried forward to these.
.Sp
The closing curly bracket finalizes the rule set. You should not write
a ';' after that, because that would be an empty rule.
.Sp
Example:
.Sp
.Vb 4
\&    chain INPUT proto icmp {
\&        icmp\-type echo\-request ACCEPT;
\&        DROP;
\&    }
.Ve
.Sp
This block shows two rules inside a block, which will both be merged
with anything in front of it, so you will get two rules:
.Sp
.Vb 2
\&    iptables \-A INPUT \-p icmp \-\-icmp\-type echo\-request \-j ACCEPT
\&    iptables \-A INPUT \-p icmp \-j DROP
.Ve
.Sp
There can be multiple nesting levels:
.Sp
.Vb 7
\&    chain INPUT {
\&        proto icmp {
\&            icmp\-type echo\-request ACCEPT;
\&            DROP;
\&        }
\&        daddr 172.16.0.0/12 REJECT;
\&    }
.Ve
.Sp
Note that the '\s-1REJECT\s0' rule is not affected by 'proto icmp', although
there is no ';' after the closing curly brace. Translated to iptables:
.Sp
.Vb 3
\&    iptables \-A INPUT \-p icmp \-\-icmp\-type echo\-request \-j ACCEPT
\&    iptables \-A INPUT \-p icmp \-j DROP
\&    iptables \-A INPUT \-d 172.16.0.0/12 \-j REJECT
.Ve
.IP "\fB$\fR" 8
.IX Item "$"
Variable expansion. Replaces '$FOO' by the value of the variable. See
the section \fI\s-1VARIABLES\s0\fR for details.
.IP "\fB&\fR" 8
.IX Item "&"
Function call. See the section \fI\s-1FUNCTIONS\s0\fR for details.
.IP "\fB()\fR" 8
.IX Item "()"
The array symbol. Using the parentheses, you can define
a 'list' of values that should be applied for the key to the
left of it.
.Sp
Example:
.Sp
.Vb 1
\&    protocol ( tcp udp icmp )
.Ve
.Sp
this will result in three rules:
.Sp
.Vb 3
\&    ... \-p tcp ...
\&    ... \-p udp ...
\&    ... \-p icmp ...
.Ve
.Sp
Only values can be 'listed', so you cannot do something like this:
.Sp
.Vb 1
\&    proto tcp ( ACCEPT LOG );
.Ve
.Sp
but you can do this:
.Sp
.Vb 1
\&    chain (INPUT OUTPUT FORWARD) proto (icmp udp tcp) DROP;
.Ve
.Sp
(which will result in nine rules!)
.Sp
Values are separated by spaces. The array symbol is both left\- and
right-associative, in contrast with the nesting block, which is
left-associative only.
.ie n .IP """ # """ 8
.el .IP "\f(CW # \fR" 8
.IX Item " # "
The comment symbol. Anything that follows this symbol up to
the end of line is ignored.
.ie n .IP """\`command\`""" 8
.el .IP "\f(CW\`command\`\fR" 8
.IX Item "command"
Execute the command in a shell, and insert the process output. See the
section \fIbackticks\fR for details.
.ie n .IP "\*(Aqstring\*(Aq" 8
.el .IP "\f(CW\*(Aqstring\*(Aq\fR" 8
.IX Item "string"
Quote a string which may contain whitespaces, the dollar sign etc.
.Sp
.Vb 1
\&    LOG log\-prefix \*(Aq hey, this is my log prefix!\*(Aq;
.Ve
.ie n .IP """string""" 8
.el .IP "\f(CW``string''\fR" 8
.IX Item """string"""
Quote a string (see above), but variable references with a dollar sign
are evaluated:
.Sp
.Vb 1
\&    DNAT to "$myhost:$myport";
.Ve
.SS "Keywords"
.IX Subsection "Keywords"
In the previous section, we already introduced some basic keywords
like \*(L"chain\*(R", \*(L"protocol\*(R" and \*(L"\s-1ACCEPT\*(R".\s0 Let's explore their nature.
.PP
There are three kinds of keywords:
.IP "\(bu" 8
\&\fBlocation\fR keywords define where a rule will be created. Example:
\&\*(L"table\*(R", \*(L"chain\*(R".
.IP "\(bu" 8
\&\fBmatch\fR keywords perform a test on all passing packets. The current
rule is without effect if one (or more) of the matches does not
pass. Example: \*(L"proto\*(R", \*(L"daddr\*(R".
.Sp
Most matches are followed by a parameter: \*(L"proto tcp\*(R", \*(L"daddr
172.16.0.0/12\*(R".
.IP "\(bu" 8
\&\fBtarget\fR keywords state what to do with a packet. Example: \*(L"\s-1ACCEPT\*(R",
\&\*(L"REJECT\*(R", \s0\*(L"jump\*(R".
.Sp
Some targets define more keywords to specify details: \*(L"\s-1REJECT\s0
reject-with icmp-net-unreachable\*(R".
.PP
Every rule consists of a \fBlocation\fR and a \fBtarget\fR, plus any number
of \fBmatches\fR:
.PP
.Vb 3
\&    table filter                  # location
\&    proto tcp dport (http https)  # match
\&    ACCEPT;                       # target
.Ve
.PP
Strictly speaking, there is a fourth kind: \fBferm\fR keywords (which
control ferm's internal behaviour), but they will be explained later.
.SS "Parameters"
.IX Subsection "Parameters"
Many keywords take parameters. These can be specified as literals,
variable references or lists (arrays):
.PP
.Vb 4
\&    proto udp
\&    saddr $TRUSTED_HOSTS;
\&    proto tcp dport (http https ssh);
\&    LOG log\-prefix "funky wardriver alert: ";
.Ve
.PP
Some of them can be negated (lists cannot be negated):
.PP
.Vb 2
\&    proto !esp;
\&    proto udp dport !domain;
.Ve
.PP
Keywords which take no parameters are negated by a prefixed '!':
.PP
.Vb 1
\&    proto tcp !syn;
.Ve
.PP
Read \fIiptables\fR\|(8) to see where the \fB!\fR can be used.
.SH "BASIC KEYWORDS"
.IX Header "BASIC KEYWORDS"
.SS "Location keywords"
.IX Subsection "Location keywords"
.IP "\fBdomain [ip|ip6]\fR" 8
.IX Item "domain [ip|ip6]"
Set the domain. \*(L"ip\*(R" is default and means \*(L"IPv4\*(R" (iptables). \*(L"ip6\*(R" is
for IPv6 support, using \*(L"ip6tables\*(R".
.IP "\fBtable [filter|nat|mangle]\fR" 8
.IX Item "table [filter|nat|mangle]"
Specifies which netfilter table this rule will be inserted to:
\&\*(L"filter\*(R" (default), \*(L"nat\*(R" or \*(L"mangle\*(R".
.IP "\fBchain [chain\-name]\fR" 8
.IX Item "chain [chain-name]"
Specifies the netfilter chain (within the current table) this rule
will be inserted to. Common predefined chain names are \*(L"\s-1INPUT\*(R",
\&\*(L"OUTPUT\*(R", \*(L"FORWARD\*(R", \*(L"PREROUTING\*(R", \*(L"POSTROUTING\*(R",\s0 depending on the
table. See the netfilter documentation for details.
.Sp
If you specify a non-existing chain here, ferm will add the rule to a
custom chain with that name.
.IP "\fBpolicy [ACCEPT|DROP|..]\fR" 8
.IX Item "policy [ACCEPT|DROP|..]"
Specifies the default policy for the current chain (built-in
only). Can be one of the built-in targets (\s-1ACCEPT, DROP, REJECT,
\&...\s0). A packet that matches no rules in a chain will be treated as
specified by the policy.
.Sp
To avoid ambiguity, always specify the policies of all predefined
chains explicitly.
.ie n .IP "\fB\fB@subchain\fB [""\s-1CHAIN\-NAME""\s0] { ... }\fR" 8
.el .IP "\fB\f(CB@subchain\fB [``\s-1CHAIN\-NAME''\s0] { ... }\fR" 8
.IX Item "@subchain [CHAIN-NAME] { ... }"
Works like the normal block operators (i.e. without the \fI\f(CI@subchain\fI\fR
keyword), except that \fBferm\fR moves rules within the curly braces into
a new custom chain. The name for this chain is chosen automatically by
ferm.
.Sp
In many cases, this is faster than just a block, because the kernel
may skip a huge block of rules when a precondition is false. Imagine
the following example:
.Sp
.Vb 6
\& table filter chain INPUT {
\&     saddr (1.2.3.4 2.3.4.5 3.4.5.6 4.5.6.7 5.6.7.8) {
\&         proto tcp dport (http https ssh) ACCEPT;
\&         proto udp dport domain ACCEPT;
\&     }
\& }
.Ve
.Sp
This generates 20 rules. When a packet arrives which does not pass the
\&\fBsaddr\fR match, it nonetheless checks all 20 rules. With \fB\f(CB@subchain\fB\fR,
this check is done once, resulting in faster network filtering and
less \s-1CPU\s0 load:
.Sp
.Vb 6
\& table filter chain INPUT {
\&     saddr (1.2.3.4 2.3.4.5 3.4.5.6 4.5.6.7 5.6.7.8) @subchain {
\&         proto tcp dport (http https ssh) ACCEPT;
\&         proto udp dport domain ACCEPT;
\&     }
\& }
.Ve
.Sp
Optionally, you may define the name of the sub chain:
.Sp
.Vb 4
\& saddr (1.2.3.4 2.3.4.5 3.4.5.6) @subchain "foobar" {
\&     proto tcp dport (http https ssh) ACCEPT;
\&     proto udp dport domain ACCEPT;
\& }
.Ve
.Sp
The name can either be a quoted string literal, or an expanded ferm
expression such as \f(CW@ca\fRt(\*(L"interface_\*(R", \f(CW$iface\fR) or \f(CW@subst\fRr($var,0,20).
.Sp
You can achieve the same by explicitly declaring a custom chain, but
you may feel that using \fB\f(CB@subchain\fB\fR requires less typing.
.ie n .IP "\fB\fB@gotosubchain\fB [""\s-1CHAIN\-NAME""\s0] { ... }\fR" 8
.el .IP "\fB\f(CB@gotosubchain\fB [``\s-1CHAIN\-NAME''\s0] { ... }\fR" 8
.IX Item "@gotosubchain [CHAIN-NAME] { ... }"
Works like \fB\f(CB@subchain\fB\fR except that instead of using \fBjump\fR target it
uses \fBgoto\fR target. See discussion below for the difference between
these two targets.
.SS "Basic iptables match keywords"
.IX Subsection "Basic iptables match keywords"
.IP "\fBinterface [interface\-name]\fR" 8
.IX Item "interface [interface-name]"
Define the interface name, your outside network card, like eth0,
or dialup like ppp1, or whatever device you want to match for
passing packets. It is equivalent to the \f(CW\*(C`\-i\*(C'\fR switch in
\&\fIiptables\fR\|(8).
.IP "\fBouterface [interface\-name]\fR" 8
.IX Item "outerface [interface-name]"
Same as interface, only for matching the outgoing interface
for a packet, as in \fIiptables\fR\|(8).
.IP "\fBprotocol [protocol\-name|protocol\-number]\fR" 8
.IX Item "protocol [protocol-name|protocol-number]"
Currently supported by the kernel are tcp, udp and icmp, or
their respective numbers.
.IP "\fBsaddr|daddr [address\-spec]\fR" 8
.IX Item "saddr|daddr [address-spec]"
Matches on packets originating from the specified address (saddr) or
targeted at the address (daddr).
.Sp
Examples:
.Sp
.Vb 3
\&    saddr 192.168/8 ACCEPT; # (identical to the next one:)
\&    saddr 192.168.0.0/255.255.255.0 ACCEPT;
\&    daddr my.domain.com ACCEPT;
.Ve
.IP "\fBfragment\fR" 8
.IX Item "fragment"
Specify that only fragmented \s-1IP\s0 packets should be matched.
When packets are larger that the maximum packet size your
system can handle (called Maximum Transmission Unit or \s-1MTU\s0)
they will be chopped into bits and sent one by one as single
packets. See \fIifconfig\fR\|(8) if you want to find the \s-1MTU\s0 for
your system (the default is usually 1500 bytes).
.Sp
Fragments are frequently used in \s-1DOS\s0 attacks, because there
is no way of finding out the origin of a fragment packet.
.IP "\fBsport|dport [port\-spec]\fR" 8
.IX Item "sport|dport [port-spec]"
Matches on packets on the specified \s-1TCP\s0 or \s-1UDP\s0 port. \*(L"sport\*(R" matches
the source port, and dport matches the destination port.
.Sp
This match can be used only after you specified \*(L"protocol tcp\*(R" or
\&\*(L"protocol udp\*(R", because only these two protocols actually have ports.
.Sp
And some examples of valid ports/ranges:
.Sp
.Vb 5
\&    dport 80 ACCEPT;
\&    dport http ACCEPT;
\&    dport ssh:http ACCEPT;
\&    dport 0:1023 ACCEPT; # equivalent to :1023
\&    dport 1023:65535 ACCEPT;
.Ve
.IP "\fBsyn\fR" 8
.IX Item "syn"
Specify that the \s-1SYN\s0 flag in a tcp package should be matched,
which are used to build new tcp connections. You can identify
incoming connections with this, and decide wether you want
to allow it or not. Packets that do not have this flag are
probably from an already established connection, so it's
considered reasonably safe to let these through.
.IP "\fBmodule [module\-name]\fR" 8
.IX Item "module [module-name]"
Load an iptables module. Most modules provide more match
keywords. We'll get to that later.
.SS "Basic target keywords"
.IX Subsection "Basic target keywords"
.IP "\fBjump [custom\-chain\-name]\fR" 8
.IX Item "jump [custom-chain-name]"
Jumps to a custom chain. If no rule in the custom chain matched,
netfilter returns to the next rule in the previous chain.
.IP "\fBgoto [custom\-chain\-name]\fR" 8
.IX Item "goto [custom-chain-name]"
Go to a custom chain.  Unlike the \fBjump\fR option, \fB\s-1RETURN\s0\fR will not
continue processing in this chain but instead in the chain that called
us via \fBjump\fR.
.IP "\fB\s-1ACCEPT\s0\fR" 8
.IX Item "ACCEPT"
Accepts matching packets.
.IP "\fB\s-1DROP\s0\fR" 8
.IX Item "DROP"
Drop matching packets without further notice.
.IP "\fB\s-1REJECT\s0\fR" 8
.IX Item "REJECT"
Rejects matching packets, i.e. send an \s-1ICMP\s0 packet to the sender,
which is port-unreachable by default. You may specify another \s-1ICMP\s0
type.
.Sp
.Vb 2
\&    REJECT; # default to icmp\-port\-unreachable
\&    REJECT reject\-with icmp\-net\-unreachable;
.Ve
.Sp
Type \*(L"iptables \-j \s-1REJECT\s0 \-h\*(R" for details.
.IP "\fB\s-1RETURN\s0\fR" 8
.IX Item "RETURN"
Finish the current chain and return to the calling chain (if \*(L"jump
[custom\-chain\-name]\*(R" was used).
.IP "\fB\s-1NOP\s0\fR" 8
.IX Item "NOP"
No action at all.
.SH "ADDITIONAL KEYWORDS"
.IX Header "ADDITIONAL KEYWORDS"
Netfilter is modular. Modules may provide additional targets and match
keywords. The list of netfilter modules is constantly growing, and
ferm tries to keep up with supporting them all. This chapter describes
modules which are currently supported.
.SS "iptables match modules"
.IX Subsection "iptables match modules"
.IP "\fBaccount\fR" 8
.IX Item "account"
Account traffic for all hosts in defined network/netmask.  This is one
of the match modules which behave like a target, i.e. you will mostly
have to use the \fB\s-1NOP\s0\fR target.
.Sp
.Vb 1
\&    mod account aname mynetwork aaddr 192.168.1.0/24 ashort NOP;
.Ve
.IP "\fBaddrtype\fR" 8
.IX Item "addrtype"
Check the address type; either source address or destination address.
.Sp
.Vb 2
\&    mod addrtype src\-type BROADCAST;
\&    mod addrtype dst\-type LOCAL;
.Ve
.Sp
Type \*(L"iptables \-m addrtype \-h\*(R" for details.
.IP "\fBah\fR" 8
.IX Item "ah"
Checks the \s-1SPI\s0 header in an \s-1AH\s0 packet.
.Sp
.Vb 2
\&    mod ah ahspi 0x101;
\&    mod ah ahspi ! 0x200:0x2ff;
.Ve
.Sp
Additional arguments for IPv6:
.Sp
.Vb 3
\&    mod ah ahlen 32 ACCEPT;
\&    mod ah ahlen !32 ACCEPT;
\&    mod ah ahres ACCEPT;
.Ve
.IP "\fBbpf\fR" 8
.IX Item "bpf"
Match using Linux Socket Filter.
.Sp
.Vb 1
\&    mod bpf bytecode "4,48 0 0 9,21 0 1 6,6 0 0 1,6 0 0 0";
.Ve
.IP "\fBcomment\fR" 8
.IX Item "comment"
Adds a comment of up to 256 characters to a rule, without an effect.
Note that unlike ferm comments ('#'), this one will show up in
\&\*(L"iptables \-L\*(R".
.Sp
.Vb 1
\&    mod comment comment "This is my comment." ACCEPT;
.Ve
.IP "\fBcondition\fR" 8
.IX Item "condition"
Matches if a value in /proc/net/ipt_condition/NAME is 1 (path is
/proc/net/ip6t_condition/NAME for the ip6 domain).
.Sp
.Vb 2
\&    mod condition condition (abc def) ACCEPT;
\&    mod condition condition !foo ACCEPT;
.Ve
.IP "\fBconnbytes\fR" 8
.IX Item "connbytes"
Match by how many bytes or packets a connection (or one of the two
flows constituting the connection) have tranferred so far, or by
average bytes per packet.
.Sp
.Vb 2
\&    mod connbytes connbytes 65536: connbytes\-dir both connbytes\-mode bytes ACCEPT;
\&    mod connbytes connbytes !1024:2048 connbytes\-dir reply connbytes\-mode packets ACCEPT;
.Ve
.Sp
Valid values for \fIconnbytes-dir\fR: \fIoriginal\fR, \fIreply\fR, \fIboth\fR; for
\&\fIconnbytes-mode\fR: \fIpackets\fR, \fIbytes\fR, \fIavgpkt\fR.
.IP "\fBconnlabel\fR" 8
.IX Item "connlabel"
Module matches or adds connlabels to a connection.
.Sp
.Vb 2
\&    mod connlabel label "name";
\&    mod connlabel label "name" set;
.Ve
.IP "\fBconnlimit\fR" 8
.IX Item "connlimit"
Allows you to restrict the number of parallel \s-1TCP\s0 connections to a
server per client \s-1IP\s0 address (or address block).
.Sp
.Vb 3
\&    mod connlimit connlimit\-above 4 REJECT;
\&    mod connlimit connlimit\-above !4 ACCEPT;
\&    mod connlimit connlimit\-above 4 connlimit\-mask 24 REJECT;
.Ve
.IP "\fBconnmark\fR" 8
.IX Item "connmark"
Check the mark field associated with the connection, set by the
\&\s-1CONNMARK\s0 target.
.Sp
.Vb 2
\&    mod connmark mark 64;
\&    mod connmark mark 6/7;
.Ve
.IP "\fBconntrack\fR" 8
.IX Item "conntrack"
Check connection tracking information.
.Sp
.Vb 11
\&    mod conntrack ctstate (ESTABLISHED RELATED);
\&    mod conntrack ctproto tcp;
\&    mod conntrack ctorigsrc 192.168.0.2;
\&    mod conntrack ctorigdst 1.2.3.0/24;
\&    mod conntrack ctorigsrcport 67;
\&    mod conntrack ctorigdstport 22;
\&    mod conntrack ctreplsrc 2.3.4.5;
\&    mod conntrack ctrepldst ! 3.4.5.6;
\&    mod conntrack ctstatus ASSURED;
\&    mod conntrack ctexpire 60;
\&    mod conntrack ctexpire 180:240;
.Ve
.Sp
Type \*(L"iptables \-m conntrack \-h\*(R" for details.
.IP "\fBcpu\fR" 8
.IX Item "cpu"
Match cpu handling this packet.
.Sp
.Vb 1
\&    mod cpu cpu 0;
.Ve
.IP "\fBdccp\fR" 8
.IX Item "dccp"
Check \s-1DCCP \s0(Datagram Congestion Control Protocol) specific attributes.
This module is automatically loaded when you use \*(L"protocol dccp\*(R".
.Sp
.Vb 4
\&    proto dccp sport 1234 dport 2345 ACCEPT;
\&    proto dccp dccp\-types (SYNCACK ACK) ACCEPT;
\&    proto dccp dccp\-types !REQUEST DROP;
\&    proto dccp dccp\-option 2 ACCEPT;
.Ve
.IP "\fBdscp\fR" 8
.IX Item "dscp"
Match the 6 bit \s-1DSCP\s0 field within the \s-1TOS\s0 field.
.Sp
.Vb 2
\&    mod dscp dscp 11;
\&    mod dscp dscp\-class AF41;
.Ve
.IP "\fBdst\fR" 8
.IX Item "dst"
Match the parameters in Destination Options header (IPv6).
.Sp
.Vb 2
\&    mod dst dst\-len 10;
\&    mod dst dst\-opts (type1 type2 ...);
.Ve
.IP "\fBecn\fR" 8
.IX Item "ecn"
Match the \s-1ECN\s0 bits of an IPv4 \s-1TCP\s0 header.
.Sp
.Vb 3
\&    mod ecn ecn\-tcp\-cwr;
\&    mod ecn ecn\-tcp\-ece;
\&    mod ecn ecn\-ip\-ect 2;
.Ve
.Sp
Type \*(L"iptables \-m ecn \-h\*(R" for details.
.IP "\fBesp\fR" 8
.IX Item "esp"
Checks the \s-1SPI\s0 header in an \s-1ESP\s0 packet.
.Sp
.Vb 2
\&    mod esp espspi 0x101;
\&    mod esp espspi ! 0x200:0x2ff;
.Ve
.IP "\fBeui64\fR" 8
.IX Item "eui64"
\&\*(L"This module matches the \s-1EUI\-64\s0 part of a stateless autoconfigured
IPv6 address.  It compares the \s-1EUI\-64\s0 derived from the source \s-1MAC\s0
address in Ehternet frame with the lower 64 bits of the IPv6 source
address.  But \*(R"Universal/Local\*(L" bit is not compared.  This module
doesn't match other link layer frame, and is only valid in the
\&\s-1PREROUTING, INPUT\s0 and \s-1FORWARD\s0 chains.\*(R"
.Sp
.Vb 1
\&    mod eui64 ACCEPT;
.Ve
.IP "\fBfuzzy\fR" 8
.IX Item "fuzzy"
\&\*(L"This module matches a rate limit based on a fuzzy logic controller [\s-1FLC\s0].\*(R"
.Sp
.Vb 1
\&    mod fuzzy lower\-limit 10 upper\-limit 20 ACCEPT;
.Ve
.IP "\fBhbh\fR" 8
.IX Item "hbh"
Matches the Hop-by-Hop Options header (ip6).
.Sp
.Vb 3
\&    mod hbh hbh\-len 8 ACCEPT;
\&    mod hbh hbh\-len !8 ACCEPT;
\&    mod hbh hbh\-opts (1:4 2:8) ACCEPT;
.Ve
.IP "\fBhl\fR" 8
.IX Item "hl"
Matches the Hop Limit field (ip6).
.Sp
.Vb 4
\&    mod hl hl\-eq (8 10) ACCEPT;
\&    mod hl hl\-eq !5 ACCEPT;
\&    mod hl hl\-gt 15 ACCEPT;
\&    mod hl hl\-lt 2 ACCEPT;
.Ve
.IP "\fBhelper\fR" 8
.IX Item "helper"
Checks which conntrack helper module tracks this connection.  The port
may be specified with \*(L"\-portnr\*(R".
.Sp
.Vb 2
\&    mod helper helper irc ACCEPT;
\&    mod helper helper ftp\-21 ACCEPT;
.Ve
.IP "\fBicmp\fR" 8
.IX Item "icmp"
Check \s-1ICMP\s0 specific attributes.  This module is automatically loaded
when you use \*(L"protocol icmp\*(R".
.Sp
.Vb 1
\&    proto icmp icmp\-type echo\-request ACCEPT;
.Ve
.Sp
This option can also be used in be \fIip6\fR domain, although this is
called \fBicmpv6\fR in \fIip6tables\fR.
.Sp
Use "iptables \-p icmp \f(CW\*(C`\-h\*(C'\fR" to obtain a list of valid \s-1ICMP\s0 types.
.IP "\fBiprange\fR" 8
.IX Item "iprange"
Match a range of IPv4 addresses.
.Sp
.Vb 2
\&    mod iprange src\-range 192.168.2.0\-192.168.3.255;
\&    mod iprange dst\-range ! 192.168.6.0\-192.168.6.255;
.Ve
.IP "\fBipv4options\fR" 8
.IX Item "ipv4options"
Match on IPv4 header options like source routing, record route,
timestamp and router-alert.
.Sp
.Vb 7
\&    mod ipv4options ssrr ACCEPT;
\&    mod ipv4options lsrr ACCEPT;
\&    mod ipv4options no\-srr ACCEPT;
\&    mod ipv4options !rr ACCEPT;
\&    mod ipv4options !ts ACCEPT;
\&    mod ipv4options !ra ACCEPT;
\&    mod ipv4options !any\-opt ACCEPT;
.Ve
.IP "\fBipv6header\fR" 8
.IX Item "ipv6header"
Matches the IPv6 extension header (ip6).
.Sp
.Vb 2
\&    mod ipv6header header !(hop frag) ACCEPT;
\&    mod ipv6header header (auth dst) ACCEPT;
.Ve
.IP "\fBhashlimit\fR" 8
.IX Item "hashlimit"
Similar to 'mod limit', but adds the ability to add per-destination or
per-port limits managed in a hash table.
.Sp
.Vb 2
\&    mod hashlimit  hashlimit 10/minute  hashlimit\-burst 30/minute
\&      hashlimit\-mode dstip  hashlimit\-name foobar  ACCEPT;
.Ve
.Sp
Possible values for hashlimit-mode: dstip dstport srcip srcport (or a
list with more than one of these).
.Sp
There are more possible settings, type \*(L"iptables \-m hashlimit \-h\*(R" for
documentation.
.IP "\fBipvs\fR" 8
.IX Item "ipvs"
Match \s-1IPVS\s0 connection properties.
.Sp
.Vb 7
\&    mod ipvs ipvs ACCEPT; # packet belongs to an IPVS connection
\&    mod ipvs vproto tcp ACCEPT; # VIP protocol to match; by number or name, e.g. "tcp
\&    mod ipvs vaddr 1.2.3.4/24 ACCEPT; # VIP address to match
\&    mod ipvs vport http ACCEPT; # VIP port to match
\&    mod ipvs vdir ORIGINAL ACCEPT; # flow direction of packet
\&    mod ipvs vmethod GATE ACCEPT; # IPVS forwarding method used
\&    mod ipvs vportctl 80; # VIP port of the controlling connection to match
.Ve
.IP "\fBlength\fR" 8
.IX Item "length"
Check the package length.
.Sp
.Vb 3
\&    mod length length 128; # exactly 128 bytes
\&    mod length length 512:768; # range
\&    mod length length ! 256; # negated
.Ve
.IP "\fBlimit\fR" 8
.IX Item "limit"
Limits the packet rate.
.Sp
.Vb 2
\&    mod limit limit 1/second;
\&    mod limit limit 15/minute limit\-burst 10;
.Ve
.Sp
Type \*(L"iptables \-m limit \-h\*(R" for details.
.IP "\fBmac\fR" 8
.IX Item "mac"
Match the source \s-1MAC\s0 address.
.Sp
.Vb 1
\&    mod mac mac\-source 01:23:45:67:89;
.Ve
.IP "\fBmark\fR" 8
.IX Item "mark"
Matches packets based on their netfilter mark field. This may be a 32
bit integer between 0 and 4294967295.
.Sp
.Vb 1
\&    mod mark mark 42;
.Ve
.IP "\fBmh\fR" 8
.IX Item "mh"
Matches the mobility header (domain \fIip6\fR).
.Sp
.Vb 1
\&    proto mh mh\-type binding\-update ACCEPT;
.Ve
.IP "\fBmultiport\fR" 8
.IX Item "multiport"
Match a set of source or destination ports (\s-1UDP\s0 and \s-1TCP\s0 only).
.Sp
.Vb 2
\&    mod multiport source\-ports (https ftp);
\&    mod multiport destination\-ports (mysql domain);
.Ve
.Sp
This rule has a big advantage over \*(L"dport\*(R" and \*(L"sport\*(R": it generates
only one rule for up to 15 ports instead of one rule for every port.
.IP "\fBnth\fR" 8
.IX Item "nth"
Match every 'n'th packet.
.Sp
.Vb 4
\&    mod nth every 3;
\&    mod nth counter 5 every 2;
\&    mod nth start 2 every 3;
\&    mod nth start 5 packet 2 every 6;
.Ve
.Sp
Type \*(L"iptables \-m nth \-h\*(R" for details.
.IP "\fBosf\fR" 8
.IX Item "osf"
Match packets depending on the operating system of the sender.
.Sp
.Vb 2
\&    mod osf genre Linux;
\&    mod osf ! genre FreeBSD ttl 1 log 1;
.Ve
.Sp
Type \*(L"iptables \-m osf \-h\*(R" for details.
.IP "\fBowner\fR" 8
.IX Item "owner"
Check information about the packet creator, namely user id, group id,
process id, session id and command name.
.Sp
.Vb 5
\&    mod owner uid\-owner 0;
\&    mod owner gid\-owner 1000;
\&    mod owner pid\-owner 5432;
\&    mod owner sid\-owner 6543;
\&    mod owner cmd\-owner "sendmail";
.Ve
.Sp
(\*(L"cmd-owner\*(R", \*(L"pid-owner\*(R" and \*(L"sid-owner\*(R" require special kernel
patches not included in the vanilla Linux kernel)
.IP "\fBphysdev\fR" 8
.IX Item "physdev"
Matches the physical device on which a packet entered or is about to
leave the machine. This is useful for bridged interfaces.
.Sp
.Vb 5
\&    mod physdev physdev\-in ppp1;
\&    mod physdev physdev\-out eth2;
\&    mod physdev physdev\-is\-in;
\&    mod physdev physdev\-is\-out;
\&    mod physdev physdev\-is\-bridged;
.Ve
.IP "\fBpkttype\fR" 8
.IX Item "pkttype"
Check the link-layer packet type.
.Sp
.Vb 3
\&    mod pkttype pkt\-type unicast;
\&    mod pkttype pkt\-type broadcase;
\&    mod pkttype pkt\-type multicast;
.Ve
.IP "\fBpolicy\fR" 8
.IX Item "policy"
Matches IPsec policy being applied to this packet.
.Sp
.Vb 5
\&    mod policy dir out pol ipsec ACCEPT;
\&    mod policy strict reqid 23 spi 0x10 proto ah ACCEPT;
\&    mod policy mode tunnel tunnel\-src 192.168.1.2 ACCEPT;
\&    mod policy mode tunnel tunnel\-dst 192.168.2.1 ACCEPT;
\&    mod policy strict next reqid 24 spi 0x11 ACCEPT;
.Ve
.Sp
Note that the keyword \fIproto\fR is also used as a shorthand version of
\&\fIprotocol\fR (built-in match module).  You can fix this conflict by
always using the long keyword \fIprotocol\fR.
.IP "\fBpsd\fR" 8
.IX Item "psd"
Detect \s-1TCP/UDP\s0 port scans.
.Sp
.Vb 2
\&    mod psd psd\-weight\-threshold 21 psd\-delay\-threshold 300
\&      psd\-lo\-ports\-weight 3 psd\-hi\-ports\-weight 1 DROP;
.Ve
.IP "\fBquota\fR" 8
.IX Item "quota"
Implements network quotas by decrementing a byte counter with each packet.
.Sp
.Vb 1
\&    mod quota quota 65536 ACCEPT;
.Ve
.IP "\fBrandom\fR" 8
.IX Item "random"
Match a random percentage of all packets.
.Sp
.Vb 1
\&    mod random average 70;
.Ve
.IP "\fBrealm\fR" 8
.IX Item "realm"
Match the routing realm. Useful in environments using \s-1BGP.\s0
.Sp
.Vb 1
\&    mod realm realm 3;
.Ve
.IP "\fBrecent\fR" 8
.IX Item "recent"
Temporarily mark source \s-1IP\s0 addresses.
.Sp
.Vb 6
\&    mod recent set;
\&    mod recent rcheck seconds 60;
\&    mod recent set rsource name "badguy";
\&    mod recent set rdest;
\&    mod recent rcheck rsource name "badguy" seconds 60;
\&    mod recent update seconds 120 hitcount 3 rttl;
.Ve
.Sp
This netfilter module has a design flaw: although it is implemented as
a match module, it has target-like behaviour when using the \*(L"set\*(R"
keyword.
.Sp
<http://snowman.net/projects/ipt_recent/>
.IP "\fBrpfilter\fR" 8
.IX Item "rpfilter"
Checks a reply to the packet would be sent via the same interface it arrived on.
Packets from the loopback interface are always permitted.
.Sp
.Vb 3
\&    mod rpfilter proto tcp loose RETURN;
\&    mod rpfilter validmark accept\-local RETURN;
\&    mod rpfilter invert DROP;
.Ve
.Sp
This netfilter module is the preferred way to perform reverse path filtering for
IPv6, and a powerful alternative to checks controlled by sysctl
\&\fInet.ipv4.conf.*.rp_filter\fR.
.IP "\fBrt\fR" 8
.IX Item "rt"
Match the IPv6 routing header (ip6 only).
.Sp
.Vb 5
\&    mod rt rt\-type 2 rt\-len 20 ACCEPT;
\&    mod rt rt\-type !2 rt\-len !20 ACCEPT;
\&    mod rt rt\-segsleft 2:3 ACCEPT;
\&    mod rt rt\-segsleft !4:5 ACCEPT;
\&    mod rt rt\-0\-res rt\-0\-addrs (::1 ::2) rt\-0\-not\-strict ACCEPT;
.Ve
.IP "\fBsctp\fR" 8
.IX Item "sctp"
Check \s-1SCTP \s0(Stream Control Transmission Protocol) specific attributes.
This module is automatically loaded when you use \*(L"protocol sctp\*(R".
.Sp
.Vb 4
\&    proto sctp sport 1234 dport 2345 ACCEPT;
\&    proto sctp chunk\-types only DATA:Be ACCEPT;
\&    proto sctp chunk\-types any (INIT INIT_ACK) ACCEPT;
\&    proto sctp chunk\-types !all (HEARTBEAT) ACCEPT;
.Ve
.Sp
Use "iptables \-p sctp \f(CW\*(C`\-h\*(C'\fR" to obtain a list of valid chunk types.
.IP "\fBset\fR" 8
.IX Item "set"
Checks the source or destination IP/Port/MAC against a set.
.Sp
.Vb 1
\&    mod set set badguys src DROP;
.Ve
.Sp
See <http://ipset.netfilter.org/> for more information.
.IP "\fBstate\fR" 8
.IX Item "state"
Checks the connection tracking state.
.Sp
.Vb 2
\&    mod state state INVALID DROP;
\&    mod state state (ESTABLISHED RELATED) ACCEPT;
.Ve
.Sp
Type \*(L"iptables \-m state \-h\*(R" for details.
.IP "\fBstatistic\fR" 8
.IX Item "statistic"
Successor of \fBnth\fR and \fBrandom\fR, currently undocumented in the
\&\fIiptables\fR\|(8) man page.
.Sp
.Vb 2
\&    mod statistic mode random probability 0.8 ACCEPT;
\&    mod statistic mode nth every 5 packet 0 DROP;
.Ve
.IP "\fBstring\fR" 8
.IX Item "string"
Matches a string.
.Sp
.Vb 2
\&    mod string string "foo bar" ACCEPT;
\&    mod string algo kmp from 64 to 128 hex\-string "deadbeef" ACCEPT;
.Ve
.IP "\fBtcp\fR" 8
.IX Item "tcp"
Checks \s-1TCP\s0 specific attributes. This module is automatically loaded
when you use \*(L"protocol tcp\*(R".
.Sp
.Vb 8
\&    proto tcp sport 1234;
\&    proto tcp dport 2345;
\&    proto tcp tcp\-flags (SYN ACK) SYN;
\&    proto tcp tcp\-flags ! (SYN ACK) SYN;
\&    proto tcp tcp\-flags ALL (RST ACK);
\&    proto tcp syn;
\&    proto tcp tcp\-option 2;
\&    proto tcp mss 512;
.Ve
.Sp
Type \*(L"iptables \-p tcp \-h\*(R" for details.
.IP "\fBtcpmss\fR" 8
.IX Item "tcpmss"
Check the \s-1TCP MSS\s0 field of a \s-1SYN\s0 or \s-1SYN/ACK\s0 packet.
.Sp
.Vb 2
\&    mod tcpmss mss 123 ACCEPT;
\&    mod tcpmss mss 234:567 ACCEPT;
.Ve
.IP "\fBtime\fR" 8
.IX Item "time"
Check if the time a packet arrives is in given range.
.Sp
.Vb 10
\&    mod time timestart 12:00;
\&    mod time timestop 13:30;
\&    mod time days (Mon Wed Fri);
\&    mod time datestart 2005:01:01;
\&    mod time datestart 2005:01:01:23:59:59;
\&    mod time datestop 2005:04:01;
\&    mod time monthday (30 31);
\&    mod time weekdays (Wed Thu);
\&    mod time timestart 12:00 utc;
\&    mod time timestart 12:00 localtz;
.Ve
.Sp
Type \*(L"iptables \-m time \-h\*(R" for details.
.IP "\fBtos\fR" 8
.IX Item "tos"
Matches a packet on the specified TOS-value.
.Sp
.Vb 2
\&    mod tos tos Minimize\-Cost ACCEPT;
\&    mod tos tos !Normal\-Service ACCEPT;
.Ve
.Sp
Type \*(L"iptables \-m tos \-h\*(R" for details.
.IP "\fBttl\fR" 8
.IX Item "ttl"
Matches the ttl (time to live) field in the \s-1IP\s0 header.
.Sp
.Vb 3
\&    mod ttl ttl\-eq 12; # ttl equals
\&    mod ttl ttl\-gt 10; # ttl greater than
\&    mod ttl ttl\-lt 16; # ttl less than
.Ve
.IP "\fBu32\fR" 8
.IX Item "u32"
Compares raw data from the packet.  You can specify more than one
filter in a ferm list; these are not expanded into multiple rules.
.Sp
.Vb 2
\&    mod u32 u32 \*(Aq6&0xFF=1\*(Aq ACCEPT;
\&    mod u32 u32 (\*(Aq27&0x8f=7\*(Aq \*(Aq31=0x527c4833\*(Aq) DROP;
.Ve
.IP "\fBunclean\fR" 8
.IX Item "unclean"
Matches packets which seem malformed or unusual. This match has no
further parameters.
.SS "iptables target modules"
.IX Subsection "iptables target modules"
The following additional targets are available in ferm, provided that
you enabled them in your kernel:
.IP "\fB\s-1CHECKSUM\s0\fR" 8
.IX Item "CHECKSUM"
Compute packet checksum.
.Sp
.Vb 1
\&    CHECKSUM checksum\-fill;
.Ve
.IP "\fB\s-1CLASSIFY\s0\fR" 8
.IX Item "CLASSIFY"
Set the \s-1CBQ\s0 class.
.Sp
.Vb 1
\&    CLASSIFY set\-class 3:50;
.Ve
.IP "\fB\s-1CLUSTERIP\s0\fR" 8
.IX Item "CLUSTERIP"
Configure a simple cluster of nodes that share a certain \s-1IP\s0 and \s-1MAC\s0
address.  Connections are statically distributed between the nodes.
.Sp
.Vb 2
\&    CLUSTERIP new hashmode sourceip clustermac 00:12:34:45:67:89
\&      total\-nodes 4 local\-node 2 hash\-init 12345;
.Ve
.IP "\fB\s-1CONNMARK\s0\fR" 8
.IX Item "CONNMARK"
Sets the netfilter mark value associated with a connection.
.Sp
.Vb 11
\&    CONNMARK set\-xmark 42/0xff;
\&    CONNMARK set\-mark 42;
\&    CONNMARK save\-mark;
\&    CONNMARK restore\-mark;
\&    CONNMARK save\-mark nfmask 0xff ctmask 0xff;
\&    CONNMARK save\-mark mask 0x7fff;
\&    CONNMARK restore\-mark mask 0x8000;
\&    CONNMARK and\-mark 0x7;
\&    CONNMARK or\-mark 0x4;
\&    CONNMARK xor\-mark 0x7;
\&    CONNMARK and\-mark 0x7;
.Ve
.IP "\fB\s-1CONNSECMARK\s0\fR" 8
.IX Item "CONNSECMARK"
This module copies security markings from packets to connections (if
unlabeled), and from connections back to packets (also only if
unlabeled).  Typically used in conjunction with \s-1SECMARK,\s0 it is only
valid in the mangle table.
.Sp
.Vb 2
\&    CONNSECMARK save;
\&    CONNSECMARK restore;
.Ve
.IP "\fB\s-1DNAT\s0 to [ip\-address|ip\-range|ip\-port\-range]\fR" 8
.IX Item "DNAT to [ip-address|ip-range|ip-port-range]"
Change the destination address of the packet.
.Sp
.Vb 4
\&    DNAT to 10.0.0.4;
\&    DNAT to 10.0.0.4:80;
\&    DNAT to 10.0.0.4:1024\-2048;
\&    DNAT to 10.0.1.1\-10.0.1.20;
.Ve
.IP "\fB\s-1DNPT\s0\fR" 8
.IX Item "DNPT"
Provides stateless destination IPv6\-to\-IPv6 Network Prefix Translation.
.Sp
.Vb 1
\&    DNPT src\-pfx 2001:42::/16 dst\-pfx 2002:42::/16;
.Ve
.IP "\fB\s-1ECN\s0\fR" 8
.IX Item "ECN"
This target allows to selectively work around known \s-1ECN\s0 blackholes.
It can only be used in the mangle table.
.Sp
.Vb 1
\&    ECN ecn\-tcp\-remove;
.Ve
.IP "\fB\s-1HL\s0\fR" 8
.IX Item "HL"
Modify the IPv6 Hop Limit field (ip6/mangle only).
.Sp
.Vb 3
\&    HL hl\-set 5;
\&    HL hl\-dec 2;
\&    HL hl\-inc 1;
.Ve
.IP "\fB\s-1HMARK\s0\fR" 8
.IX Item "HMARK"
Like \s-1MARK,\s0 i.e.  set the fwmark, but the mark is calculated from
hashing packet selector at choice.
.Sp
.Vb 4
\&    HMARK hmark\-tuple "src" hmark\-mod "1" hmark\-offset "1"
\&      hmark\-src\-prefix 192.168.1.0/24 hmark\-dst\-prefix 192.168.2.0/24
\&      hmark\-sport\-mask 0x1234 hmark\-dport\-mask 0x2345
\&      hmark\-spi\-mask 0xdeadbeef hmark\-proto\-mask 0x42 hmark\-rnd 0xcoffee;
.Ve
.IP "\fB\s-1IDLETIMER\s0\fR" 8
.IX Item "IDLETIMER"
This target can be used to identify when interfaces have been idle for
a certain period of time.
.Sp
.Vb 1
\&    IDLETIMER timeout 60 label "foo";
.Ve
.IP "\fB\s-1IPV4OPTSSTRIP\s0\fR" 8
.IX Item "IPV4OPTSSTRIP"
Strip all the \s-1IP\s0 options from a packet.  This module does not take any
options.
.Sp
.Vb 1
\&    IPV4OPTSSTRIP;
.Ve
.IP "\fB\s-1LED\s0\fR" 8
.IX Item "LED"
This creates an LED-trigger that can then be attached to system
indicator lights, to blink or illuminate them when certain packets
pass through the system.
.Sp
.Vb 1
\&    LED led\-trigger\-id "foo" led\-delay 100 led\-always\-blink;
.Ve
.IP "\fB\s-1LOG\s0\fR" 8
.IX Item "LOG"
Log all packets that match this rule in the kernel log. Be carefull
with log flooding. Note that this is a \*(L"non-terminating target\*(R",
i.e. rule traversal continues at the next rule.
.Sp
.Vb 3
\&    LOG log\-level warning log\-prefix "Look at this: ";
\&    LOG log\-tcp\-sequence log\-tcp\-options;
\&    LOG log\-ip\-options;
.Ve
.IP "\fB\s-1MARK\s0\fR" 8
.IX Item "MARK"
Sets the netfilter mark field for the packet (a 32 bit integer between
0 and 4294967295):
.Sp
.Vb 5
\&    MARK set\-mark 42;
\&    MARK set\-xmark 7/3;
\&    MARK and\-mark 31;
\&    MARK or\-mark 1;
\&    MARK xor\-mark 12;
.Ve
.IP "\fB\s-1MASQUERADE\s0\fR" 8
.IX Item "MASQUERADE"
Masquerades matching packets. Optionally followed by a port or
port-range for iptables. Specify as \*(L"123\*(R", \*(L"123\-456\*(R" or \*(L"123:456\*(R".
The port range parameter specifies what local ports masqueraded
connections should originate from.
.Sp
.Vb 3
\&    MASQUERADE;
\&    MASQUERADE to\-ports 1234:2345;
\&    MASQUERADE to\-ports 1234:2345 random;
.Ve
.IP "\fB\s-1MIRROR\s0\fR" 8
.IX Item "MIRROR"
Experimental demonstration target which inverts the source and
destination fields in the \s-1IP\s0 header.
.Sp
.Vb 1
\&    MIRROR;
.Ve
.IP "\fB\s-1NETMAP\s0\fR" 8
.IX Item "NETMAP"
Map a whole network onto another network in the \fBnat\fR table.
.Sp
.Vb 1
\&    NETMAP to 192.168.2.0/24;
.Ve
.IP "\fB\s-1NOTRACK\s0\fR" 8
.IX Item "NOTRACK"
Disable connection tracking for all packets matching that rule.
.Sp
.Vb 1
\&    proto tcp dport (135:139 445) NOTRACK;
.Ve
.IP "\fB\s-1RATEEST\s0\fR" 8
.IX Item "RATEEST"
.Vb 1
\&    RATEEST rateest\-name "foo" rateest\-interval 60s rateest\-ewmalog 100;
\&
\&    proto tcp dport (135:139 445) NOTRACK;
.Ve
.IP "\fB\s-1NFLOG\s0\fR" 8
.IX Item "NFLOG"
Log packets over netlink; this is the successor of \fI\s-1ULOG\s0\fR.
.Sp
.Vb 3
\&    NFLOG nflog\-group 5 nflog\-prefix "Look at this: ";
\&    NFLOG nflog\-range 256;
\&    NFLOG nflog\-threshold 10;
.Ve
.IP "\fB\s-1NFQUEUE\s0\fR" 8
.IX Item "NFQUEUE"
Userspace queueing, requires nfnetlink_queue kernel support.
.Sp
.Vb 1
\&    proto tcp dport ftp NFQUEUE queue\-num 20;
.Ve
.IP "\fB\s-1QUEUE\s0\fR" 8
.IX Item "QUEUE"
Userspace queueing, the predecessor to \fB\s-1NFQUEUE\s0\fR.  All packets go to
queue 0.
.Sp
.Vb 1
\&    proto tcp dport ftp QUEUE;
.Ve
.IP "\fB\s-1REDIRECT\s0 to-ports [ports]\fR" 8
.IX Item "REDIRECT to-ports [ports]"
Transparent proxying: alter the destination \s-1IP\s0 of the packet to the
machine itself.
.Sp
.Vb 2
\&    proto tcp dport http REDIRECT to\-ports 3128;
\&    proto tcp dport http REDIRECT to\-ports 3128 random;
.Ve
.IP "\fB\s-1SAME\s0\fR" 8
.IX Item "SAME"
Similar to \s-1SNAT,\s0 but a client is mapped to the same source \s-1IP\s0 for all
its connections.
.Sp
.Vb 3
\&    SAME to 1.2.3.4\-1.2.3.7;
\&    SAME to 1.2.3.8\-1.2.3.15 nodst;
\&    SAME to 1.2.3.16\-1.2.3.31 random;
.Ve
.IP "\fB\s-1SECMARK\s0\fR" 8
.IX Item "SECMARK"
This is used to set the security mark value associated with the packet
for use by security subsystems such as SELinux.  It is only valid in
the mangle table.
.Sp
.Vb 1
\&    SECMARK selctx "system_u:object_r:httpd_packet_t:s0";
.Ve
.IP "\fB\s-1SET\s0 [add\-set|del\-set] [setname] [flag(s)]\fR" 8
.IX Item "SET [add-set|del-set] [setname] [flag(s)]"
Add the \s-1IP\s0 to the specified set. See <http://ipset.netfilter.org/>
.Sp
.Vb 2
\&    proto icmp icmp\-type echo\-request SET add\-set badguys src;
\&    SET add\-set "foo" timeout 60 exist;
.Ve
.IP "\fB\s-1SNAT\s0 to [ip\-address|ip\-range|ip\-port\-range]\fR" 8
.IX Item "SNAT to [ip-address|ip-range|ip-port-range]"
Change the source address of the packet.
.Sp
.Vb 3
\&    SNAT to 1.2.3.4;
\&    SNAT to 1.2.3.4:20000\-30000;
\&    SNAT to 1.2.3.4 random;
.Ve
.IP "\fB\s-1SNPT\s0\fR" 8
.IX Item "SNPT"
Provides stateless source IPv6\-to\-IPv6 Network Prefix Translation.
.Sp
.Vb 1
\&    SNPT src\-pfx 2001:42::/16 dst\-pfx 2002:42::/16;
.Ve
.IP "\fB\s-1SYNPROXY\s0\fR" 8
.IX Item "SYNPROXY"
\&\s-1TCP\s0 3\-way handshake proxy: let the firewall handle the \s-1TCP\s0 3\-way handshake and
only establish connection with the server socket once the client handshake has
finished.
.Sp
.Vb 1
\&    SYNPROXY wscale 7 mss 1460 timestamp sack\-perm
.Ve
.IP "\fB\s-1TCPMSS\s0\fR" 8
.IX Item "TCPMSS"
Alter the \s-1MSS\s0 value of \s-1TCP SYN\s0 packets.
.Sp
.Vb 2
\&    TCPMSS set\-mss 1400;
\&    TCPMSS clamp\-mss\-to\-pmtu;
.Ve
.IP "\fB\s-1TCPOPTSTRIP\s0\fR" 8
.IX Item "TCPOPTSTRIP"
This target will strip \s-1TCP\s0 options off a \s-1TCP\s0 packet.
.Sp
.Vb 1
\&    TCPOPTSTRIP strip\-options (option1 option2 ...);
.Ve
.IP "\fB\s-1TOS\s0 set-tos [value]\fR" 8
.IX Item "TOS set-tos [value]"
Set the tcp package Type Of Service bit to this value.  This will be
used by whatever traffic scheduler is willing to, mostly your own
linux-machine, but maybe more. The original tos-bits are blanked and
overwritten by this value.
.Sp
.Vb 4
\&    TOS set\-tos Maximize\-Throughput;
\&    TOS and\-tos 7;
\&    TOS or\-tos 1;
\&    TOS xor\-tos 4;
.Ve
.Sp
Type \*(L"iptables \-j \s-1TOS\s0 \-h\*(R" for details.
.IP "\fB\s-1TTL\s0\fR" 8
.IX Item "TTL"
Modify the \s-1TTL\s0 header field.
.Sp
.Vb 3
\&    TTL ttl\-set 16;
\&    TTL ttl\-dec 1; # decrease by 1
\&    TTL ttl\-inc 4; # increase by 4
.Ve
.IP "\fB\s-1ULOG\s0\fR" 8
.IX Item "ULOG"
Log packets to a userspace program.
.Sp
.Vb 3
\&    ULOG ulog\-nlgroup 5 ulog\-prefix "Look at this: ";
\&    ULOG ulog\-cprange 256;
\&    ULOG ulog\-qthreshold 10;
.Ve
.SH "OTHER DOMAINS"
.IX Header "OTHER DOMAINS"
Since version 2.0, \fBferm\fR supports not only \fIip\fR and \fIip6\fR, but
also \fIarp\fR (\s-1ARP\s0 tables) and \fIeb\fR (ethernet bridging tables).  The
concepts are similar to \fIiptables\fR.
.SS "arptables keywords"
.IX Subsection "arptables keywords"
.IP "\fBsource-ip\fR, \fBdestination-ip\fR" 8
.IX Item "source-ip, destination-ip"
Matches the source or destination IPv4 address.  Same as \fBsaddr\fR and
\&\fBdaddr\fR in the \fIip\fR domain.
.IP "\fBsource-mac\fR, \fBdestination-mac\fR" 8
.IX Item "source-mac, destination-mac"
Matches the source or destination \s-1MAC\s0 address.
.IP "\fBinterface\fR, \fBouterface\fR" 8
.IX Item "interface, outerface"
Input and output interface.
.IP "\fBh\-length\fR" 8
.IX Item "h-length"
Hardware length of the packet.
.Sp
.Vb 1
\&    chain INPUT h\-length 64 ACCEPT;
.Ve
.IP "\fBopcode\fR" 8
.IX Item "opcode"
Operation code, for details see the \fIiptables\fR\|(8).
.Sp
.Vb 1
\&    opcode 9 ACCEPT;
.Ve
.IP "\fBh\-type\fR" 8
.IX Item "h-type"
Hardware type.
.Sp
.Vb 1
\&    h\-type 1 ACCEPT;
.Ve
.IP "\fBproto-type\fR" 8
.IX Item "proto-type"
Protocol type.
.Sp
.Vb 1
\&    proto\-type 0x800 ACCEPT;
.Ve
.IP "\fBMangling\fR" 8
.IX Item "Mangling"
The keywords \fBmangle-ip-s\fR, \fBmangle-ip-d\fR, \fBmangle-mac-s\fR,
\&\fBmangle-mac-d\fR, \fBmangle-target\fR may be used for \s-1ARP\s0 mangling.  See
\&\fIiptables\fR\|(8) for details.
.SS "ebtables keywords"
.IX Subsection "ebtables keywords"
.IP "\fBproto\fR" 8
.IX Item "proto"
Matches the protocol which created the frame, e.g. \fIIPv4\fR or \fB\s-1PPP\s0\fR.
For a list, see \fI/etc/ethertypes\fR.
.IP "\fBinterface\fR, \fBouterface\fR" 8
.IX Item "interface, outerface"
Physical input and output interface.
.IP "\fBlogical-in\fR, \fBlogical-out\fR" 8
.IX Item "logical-in, logical-out"
The logical bridge interface.
.IP "\fBsaddr\fR, \fBdaddr\fR" 8
.IX Item "saddr, daddr"
Matches source or destination \s-1MAC\s0 address.
.IP "\fBMatch modules\fR" 8
.IX Item "Match modules"
The following match modules are supported: 802.3, arp, ip, mark_m,
pkttype, stp, vlan, log.
.IP "\fBTarget extensions\fR" 8
.IX Item "Target extensions"
The following target extensions are supported: arpreply, dnat, mark,
redirect, snat.
.Sp
Please note that there is a conflict between \fI\-\-mark\fR from the
\&\fImark_m\fR match module and \fI\-j mark\fR.  Since both would be
implemented with the ferm keyword \fBmark\fR, we decided to solve this by
writing the target's name in uppercase, like in the other domains.
The following example rewrites mark 1 to 2:
.Sp
.Vb 1
\&    mark 1 MARK 2;
.Ve
.SH "ADVANCED FEATURES"
.IX Header "ADVANCED FEATURES"
.SS "Variables"
.IX Subsection "Variables"
In complex firewall files, it is helpful to use variables, e.g. to
give a network interface a meaningful name.
.PP
To set variables, write:
.PP
.Vb 3
\&    @def $DEV_INTERNET = eth0;
\&    @def $PORTS = (http ftp);
\&    @def $MORE_PORTS = ($PORTS 8080);
.Ve
.PP
In the real ferm code, variables are used like any other keyword
parameter:
.PP
.Vb 1
\&    chain INPUT interface $DEV_INTERNET proto tcp dport $MORE_PORTS ACCEPT;
.Ve
.PP
Note that variables can only be used in keyword parameters
(\*(L"192.168.1.1\*(R", \*(L"http\*(R"); they cannot contain ferm keywords like
\&\*(L"proto\*(R" or \*(L"interface\*(R".
.PP
Variables are only valid in the current block:
.PP
.Vb 8
\&    @def $DEV_INTERNET = eth1;
\&    chain INPUT {
\&        proto tcp {
\&            @def $DEV_INTERNET = ppp0;
\&            interface $DEV_INTERNET dport http ACCEPT;
\&        }
\&        interface $DEV_INTERNET DROP;
\&    }
.Ve
.PP
will be expanded to:
.PP
.Vb 6
\&    chain INPUT {
\&        proto tcp {
\&            interface ppp0 dport http ACCEPT;
\&        }
\&        interface eth1 DROP;
\&    }
.Ve
.PP
The \*(L"def \f(CW$DEV_INTERNET\fR = ppp0\*(R" is only valid in the \*(L"proto tcp\*(R" block;
the parent block still knows \*(L"set \f(CW$DEV_INTERNET\fR = eth1\*(R".
.PP
Include files are special \- variables declared in an included file are
still available in the calling block. This is useful when you include
a file which only declares variables.
.SS "Automatic variables"
.IX Subsection "Automatic variables"
Some variables are set internally by ferm. Ferm scripts can use them
just like any other variable.
.ie n .IP "\fB\fB$FILENAME\fB\fR" 8
.el .IP "\fB\f(CB$FILENAME\fB\fR" 8
.IX Item "$FILENAME"
The name of the configuration file relative to the directory ferm was
started in.
.ie n .IP "\fB\fB$FILEBNAME\fB\fR" 8
.el .IP "\fB\f(CB$FILEBNAME\fB\fR" 8
.IX Item "$FILEBNAME"
The base name of the configuration file.
.ie n .IP "\fB\fB$DIRNAME\fB\fR" 8
.el .IP "\fB\f(CB$DIRNAME\fB\fR" 8
.IX Item "$DIRNAME"
The directory of the configuration file.
.ie n .IP "\fB\fB$DOMAIN\fB\fR" 8
.el .IP "\fB\f(CB$DOMAIN\fB\fR" 8
.IX Item "$DOMAIN"
The current domain.  One of \fIip\fR, \fIip6\fR, \fIarp\fR, \fIeb\fR.
.ie n .IP "\fB\fB$TABLE\fB\fR" 8
.el .IP "\fB\f(CB$TABLE\fB\fR" 8
.IX Item "$TABLE"
The current netfilter table.
.ie n .IP "\fB\fB$CHAIN\fB\fR" 8
.el .IP "\fB\f(CB$CHAIN\fB\fR" 8
.IX Item "$CHAIN"
The current netfilter chain.
.ie n .IP "\fB\fB$LINE\fB\fR" 8
.el .IP "\fB\f(CB$LINE\fB\fR" 8
.IX Item "$LINE"
The line of the current script.  It can be used like this:
.Sp
.Vb 7
\&    @def &log($msg) = {
\&             LOG log\-prefix "rule=$msg:$LINE ";
\&    }
\&    .
\&    .
\&    .
\&    &log("log message");
.Ve
.SS "Functions"
.IX Subsection "Functions"
Functions are similar to variables, except that they may have
parameters, and they provide ferm commands, not values.
.PP
.Vb 2
\&    @def &FOO() = proto (tcp udp) dport domain;
\&    &FOO() ACCEPT;
\&
\&    @def &TCP_TUNNEL($port, $dest) = {
\&        table filter chain FORWARD interface ppp0 proto tcp dport $port daddr $dest outerface eth0 ACCEPT;
\&        table nat chain PREROUTING interface ppp0 proto tcp dport $port daddr 1.2.3.4 DNAT to $dest;
\&    }
\&
\&    &TCP_TUNNEL(http, 192.168.1.33);
\&    &TCP_TUNNEL(ftp, 192.168.1.30);
\&    &TCP_TUNNEL((ssh smtp), 192.168.1.2);
.Ve
.PP
A function call which contains a block (like '{...}') must be the last
command in a ferm rule, i.e. it must be followed by ';'. The '&\fIFOO()\fR'
example does not contain a block, thus you may write '\s-1ACCEPT\s0' after
the call. To circumvent this, you can reorder the keywords:
.PP
.Vb 2
\&    @def &IPSEC() = { proto (esp ah); proto udp dport 500; }
\&    chain INPUT ACCEPT &IPSEC();
.Ve
.SS "Backticks"
.IX Subsection "Backticks"
With backticks, you may use the output of an external command:
.PP
.Vb 2
\&    @def $DNSSERVERS = \`grep nameserver /etc/resolv.conf | awk \*(Aq{print $2}\*(Aq\`;
\&    chain INPUT proto tcp saddr $DNSSERVERS ACCEPT;
.Ve
.PP
The command is executed with the shell (\fI/bin/sh\fR), just like
backticks in perl.  ferm does not do any variable expansion here.
.PP
The output is then tokenized, and saved as a ferm list (array). Lines
beginning with '#' are ignored; the other lines may contain any number
of values, separated by whitespace.
.SS "Includes"
.IX Subsection "Includes"
The \fB\f(CB@include\fB\fR keyword allows you to include external files:
.PP
.Vb 1
\&    @include \*(Aqvars.ferm\*(Aq;
.Ve
.PP
The file name is relative to the calling file, e.g. when including
from \fI/etc/ferm/ferm.conf\fR, the above statement includes
\&\fI/etc/ferm/vars.ferm\fR. Variables and functions declared in an
included file are still available in the calling file.
.PP
\&\fBinclude\fR works within a block:
.PP
.Vb 3
\&    chain INPUT {
\&        @include \*(Aqinput.ferm\*(Aq;
\&    }
.Ve
.PP
If you specify a directory (with a trailing '/'), all files in this
directory are included, sorted alphabetically:
.PP
.Vb 1
\&    @include \*(Aqferm.d/\*(Aq;
.Ve
.PP
The function \f(CW@glob\fR can be used to expand wild cards:
.PP
.Vb 1
\&    @include @glob(\*(Aq*.include\*(Aq);
.Ve
.PP
With a trailing pipe symbol, \fBferm\fR executes a shell command and
parses its output:
.PP
.Vb 1
\&    @include "/root/generate_ferm_rules.sh $HOSTNAME|"
.Ve
.PP
\&\fBferm\fR aborts, if return code is not 0.
.SS "Conditionals"
.IX Subsection "Conditionals"
The keyword \fB\f(CB@if\fB\fR introduces a conditional expression:
.PP
.Vb 1
\&    @if $condition DROP;
.Ve
.PP
A value is evaluated true just like in Perl: zero, empty list, empty
string are false, everything else is true.  Examples for true values:
.PP
.Vb 1
\&    (a b); 1; \*(Aqfoo\*(Aq; (0 0)
.Ve
.PP
Examples for false values:
.PP
.Vb 1
\&    (); 0; \*(Aq0\*(Aq; \*(Aq\*(Aq
.Ve
.PP
There is also \fB\f(CB@else\fB\fR:
.PP
.Vb 1
\&    @if $condition DROP; @else REJECT;
.Ve
.PP
Note the semicolon before the \fB\f(CB@else\fB\fR.
.PP
It is possible to use curly braces after either \fB\f(CB@if\fB\fR or \fB\f(CB@else\fB\fR:
.PP
.Vb 6
\&    @if $condition {
\&        MARK set\-mark 2;
\&        RETURN;
\&    } @else {
\&        MARK set\-mark 3;
\&    }
.Ve
.PP
Since the closing curly brace also finishes the command, there is no
need for semicolon.
.PP
There is no \fB\f(CB@elsif\fB\fR, use \fB\f(CB@else\fB \f(CB@if\fB\fR instead.
.PP
Example:
.PP
.Vb 6
\&    @def $have_ipv6 = \`test \-f /proc/net/ip6_tables_names && echo 1 || echo\`;
\&    @if $have_ipv6 {
\&        domain ip6 {
\&            # ....
\&        }
\&    }
.Ve
.SS "Hooks"
.IX Subsection "Hooks"
To run custom commands, you may install hooks:
.PP
.Vb 3
\&    @hook pre "echo 0 >/proc/sys/net/ipv4/conf/eth0/forwarding";
\&    @hook post "echo 1 >/proc/sys/net/ipv4/conf/eth0/forwarding";
\&    @hook flush "echo 0 >/proc/sys/net/ipv4/conf/eth0/forwarding";
.Ve
.PP
The specified command is executed using the shell.  \*(L"pre\*(R" means run
the command before applying the firewall rules, and \*(L"post\*(R" means run
the command afterwards.  \*(L"flush\*(R" hooks are run after ferm has flushed
the firewall rules (option \-\-flush).  You may install any number of
hooks.
.SH "BUILT-IN FUNCTIONS"
.IX Header "BUILT-IN FUNCTIONS"
There are several built-in functions which you might find useful.
.ie n .SS "@defined($name), @defined(&name)"
.el .SS "\f(CW@define\fPd($name), \f(CW@define\fPd(&name)"
.IX Subsection "@defined($name), @defined(&name)"
Tests if the variable or function is defined.
.PP
.Vb 4
\&    @def $a = \*(Aqfoo\*(Aq;
\&    @if @defined($a) good;
\&    @if @not(@defined($a)) bad;
\&    @if @defined(&funcname) good;
.Ve
.ie n .SS "@eq(a,b)"
.el .SS "\f(CW@e\fPq(a,b)"
.IX Subsection "@eq(a,b)"
Tests two values for equality.  Example:
.PP
.Vb 1
\&    @if @eq($DOMAIN, ip6) DROP;
.Ve
.ie n .SS "@ne(a,b)"
.el .SS "\f(CW@n\fPe(a,b)"
.IX Subsection "@ne(a,b)"
Similar to \f(CW@eq\fR, this tests for non-equality.
.ie n .SS "@not(x)"
.el .SS "\f(CW@no\fPt(x)"
.IX Subsection "@not(x)"
Negates a boolean value.
.ie n .SS "@resolve((hostname1 hostname2 ...), [type])"
.el .SS "\f(CW@resolv\fPe((hostname1 hostname2 ...), [type])"
.IX Subsection "@resolve((hostname1 hostname2 ...), [type])"
Usually, host names are resolved by iptables.  To let ferm resolve
host names, use the function \f(CW@resolve:\fR
.PP
.Vb 3
\&    saddr @resolve(my.host.foo) proto tcp dport ssh ACCEPT;
\&    saddr @resolve((another.host.foo third.host.foo)) proto tcp dport openvpn ACCEPT;
\&    daddr @resolve(ipv6.google.com, AAAA) proto tcp dport http ACCEPT;
.Ve
.PP
Note the double parentheses in the second line: the inner pair for
creating a ferm list, and the outer pair as function parameter
delimiters.
.PP
The second parameter is optional, and specifies the \s-1DNS\s0 record type.
The default is \*(L"A\*(R".
.PP
Be careful with resolved host names in firewall configuration.  \s-1DNS\s0
requests may block the firewall configuration for a long time, leaving
the machine vulnerable, or they may fail.
.ie n .SS "@cat(a, b, ...)"
.el .SS "\f(CW@ca\fPt(a, b, ...)"
.IX Subsection "@cat(a, b, ...)"
Concatenate all parameters into one string.
.ie n .SS "@substr(expression, offset, length)"
.el .SS "\f(CW@subst\fPr(expression, offset, length)"
.IX Subsection "@substr(expression, offset, length)"
Extracts a substring out of expression and returns it.  First
character is at offset 0. If \s-1OFFSET\s0 is negative, starts that far from
the end of the string.
.ie n .SS "@length(expression)"
.el .SS "\f(CW@lengt\fPh(expression)"
.IX Subsection "@length(expression)"
Returns the length in characters of the value of \s-1EXPR.\s0
.ie n .SS "@basename(path)"
.el .SS "\f(CW@basenam\fPe(path)"
.IX Subsection "@basename(path)"
Return the base name of the file for a given path
(File::Spec::splitpath).
.ie n .SS "@dirname(path)"
.el .SS "\f(CW@dirnam\fPe(path)"
.IX Subsection "@dirname(path)"
Return the name of the last directory for a given path, assuming the
last component is a file name (File::Spec::splitpath).
.ie n .SS "@glob(path)"
.el .SS "\f(CW@glo\fPb(path)"
.IX Subsection "@glob(path)"
Expand shell wildcards in the given paths (assumed to be relative to
the current script).  Returns a list of matching files.  This function
is useful as parameter of \f(CW@include\fR.
.ie n .SS "@ipfilter(list)"
.el .SS "\f(CW@ipfilte\fPr(list)"
.IX Subsection "@ipfilter(list)"
Filters out the \s-1IP\s0 addresses that obviously do not match the current
domain.  That is useful to create common variables and rules for IPv4
and IPv6:
.PP
.Vb 1
\&    @def $TRUSTED_HOSTS = (192.168.0.40 2001:abcd:ef::40);
\&
\&    domain (ip ip6) chain INPUT {
\&        saddr @ipfilter($TRUSTED_HOSTS) proto tcp dport ssh ACCEPT;
\&    }
.Ve
.SH "RECIPES"
.IX Header "RECIPES"
The \fI./examples/\fR directory contains numerous ferm configuration
which can be used to begin a new firewall. This sections contains more
samples, recipes and tricks.
.SS "Easy port forwarding"
.IX Subsection "Easy port forwarding"
Ferm function make routine tasks quick and easy:
.PP
.Vb 4
\&    @def &FORWARD_TCP($proto, $port, $dest) = {
\&        table filter chain FORWARD interface $DEV_WORLD outerface $DEV_DMZ daddr $dest proto $proto dport $port ACCEPT;
\&        table nat chain PREROUTING interface $DEV_WORLD daddr $HOST_STATIC proto $proto dport $port DNAT to $dest;
\&    }
\&
\&    &FORWARD_TCP(tcp, http, 192.168.1.2);
\&    &FORWARD_TCP(tcp, smtp, 192.168.1.3);
\&    &FORWARD_TCP((tcp udp), domain, 192.168.1.4);
.Ve
.SS "Remote \fBferm\fP"
.IX Subsection "Remote ferm"
If the target machine is not able to run \fBferm\fR for some reason
(maybe an embedded device without Perl), you can edit the \fBferm\fR
configuration file on another computer and let \fBferm\fR generate a
shell script there.
.PP
Example for OpenWRT:
.PP
.Vb 4
\&    ferm \-\-remote \-\-shell mywrt/ferm.conf >mywrt/firewall.user
\&    chmod +x mywrt/firewall.user
\&    scp mywrt/firewall.user mywrt.local.net:/etc/
\&    ssh mywrt.local.net /etc/firewall.user
.Ve
.SH "OPTIONS"
.IX Header "OPTIONS"
.IP "\fB\-\-noexec\fR" 12
.IX Item "--noexec"
Do not execute the \fIiptables\fR\|(8) commands, but skip instead. This way
you can parse your data, use \fB\-\-lines\fR to view the output.
.IP "\fB\-\-flush\fR" 12
.IX Item "--flush"
Clears the firewall rules and sets the policy of all chains to \s-1ACCEPT.
\&\s0\fBferm\fR needs a configuration file for that to determine which domains
and tables are affected.
.IP "\fB\-\-lines\fR" 12
.IX Item "--lines"
Show the firewall lines that were generated from the rules. They
will be shown just before they are executed, so if you get error
messages from \fIiptables\fR\|(8) etc., you can see which rule caused
the error.
.IP "\fB\-\-interactive\fR" 12
.IX Item "--interactive"
Apply the firewall rules and ask the user for confirmation.  Reverts
to the previous ruleset if there is no valid user response within 30
seconds (see \fB\-\-timeout\fR).  This is useful for remote firewall
administration: you can test the rules without fearing to lock
yourself out.
.IP "\fB\-\-timeout S\fR" 12
.IX Item "--timeout S"
If \fB\-\-interactive\fR is used, then roll back if there is no valid user
response after this number of seconds.  The default is 30.
.IP "\fB\-\-help\fR" 12
.IX Item "--help"
Show a brief list of available commandline options.
.IP "\fB\-\-version\fR" 12
.IX Item "--version"
Shows the version number of the program.
.IP "\fB\-\-fast\fR" 12
.IX Item "--fast"
Enable fast mode: ferm generates an \fIiptables\-save\fR\|(8) file, and
installs it with \fIiptables\-restore\fR\|(8). This is much faster, because
ferm calls \fIiptables\fR\|(8) once for every rule by default.
.Sp
Fast mode is enabled by default since \fBferm\fR 2.0, deprecating this
option.
.IP "\fB\-\-slow\fR" 12
.IX Item "--slow"
Disable fast mode, i.e. run \fIiptables\fR\|(8) for every rule, and don't use
\&\fIiptables\-restore\fR\|(8).
.IP "\fB\-\-shell\fR" 12
.IX Item "--shell"
Generate a shell script which calls \fIiptables\-restore\fR\|(8) and prints it.
Implies \-\-fast \-\-lines.
.IP "\fB\-\-remote\fR" 12
.IX Item "--remote"
Generate rules for a remote machine.  Implies \fB\-\-noexec\fR and
\&\fB\-\-lines\fR.  Can be combined with \fB\-\-shell\fR.
.IP "\fB\-\-domain {ip|ip6}\fR" 12
.IX Item "--domain {ip|ip6}"
Handle only the specified domain. \fBferm\fR output may be empty if the
domain is not configured in the input file.
.IP "\fB\-\-def '$name=value'\fR" 12
.IX Item "--def '$name=value'"
Override a variable defined in the configuration file.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIiptables\fR\|(8)
.SH "REQUIREMENTS"
.IX Header "REQUIREMENTS"
.SS "Operating system"
.IX Subsection "Operating system"
Linux 2.4 or newer, with netfilter support and all netfilter modules
used by your firewall script
.SS "Software"
.IX Subsection "Software"
iptables and perl 5.6
.SH "BUGS"
.IX Header "BUGS"
Bugs? What bugs?
.PP
If you find a bug, please tell us: ferm@foo\-projects.org
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (C) 2001\-2012 Max Kellermann <max@foo\-projects.org>, Auke
Kok <sofar@foo\-projects.org>
.PP
This program is free software; you can redistribute it and/or modify
it under the terms of the \s-1GNU\s0 General Public License as published by
the Free Software Foundation; either version 2 of the License, or (at
your option) any later version.
.PP
This program is distributed in the hope that it will be useful, but
\&\s-1WITHOUT ANY WARRANTY\s0; without even the implied warranty of
\&\s-1MERCHANTABILITY\s0 or \s-1FITNESS FOR A PARTICULAR PURPOSE. \s0 See the \s-1GNU\s0
General Public License for more details.
.PP
You should have received a copy of the \s-1GNU\s0 General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, \s-1MA 02111\-1307
USA\s0
.SH "AUTHOR"
.IX Header "AUTHOR"
Max Kellermann <max@foo\-projects.org>, Auke Kok
<sofar@foo\-projects.org>
